# 排序专题

[toc]

## 关于时间复杂度、空间复杂度、稳定性

### 时间复杂度

![img](https://pics4.baidu.com/feed/77c6a7efce1b9d165ca14d16a52e01848d54645b.png@f_auto?token=5ceed36c7b9017304b3fb8688c7d6419)

1. 只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)；
2. 单层for为O(n)；
3. 将一个O(logn)的代码执行n次，就是O(nlogn)；
4. O(k^n)：各种递归基本是指数级；
5. O(n!)：典型应用求有N个元素的全排列的算法。

### 空间复杂度

基本上就是O(1)、O(n)、O(n^k)等。

### 稳定性

指的是**相同的元素**在进行排序后的相对位置会不会发生改变。

## 插入类排序

### 直接插入排序

- 直接插入排序是一种最基本的插入排序算法，是其他排序算法的基石。

- 基本操作：将第i个记录直接插入到前面**i-1个已经排好序**的记录中；保证前i-1个已经有序的情况下，将需要排序的记录后移一位，给需要插入的位置留出位置，然后将记录插入；

- 时间复杂度：O(n^2)

- 空间复杂度：O(1)

- 稳定性：稳定

```c++
void sort(vector<int> &v, const int &n) {
    for (int i = 1; i < n; ++i) {
        int now = v[i];
        for (int j = i - 1; j >= 0; --j) {
            if (now < v[j]) {
                v[j + 1] = v[j];
                v[j] = now;
            } else {
                break;
            }
        }
    }
}
```

### 折半查找排序

- 也是对直接插入排序的一种优化；
- 在对有序表进行查找的时候，折半查找的性能要由于顺序查找；使用这种思路，可以对直接插入排序进行优化；
- 时间复杂度：O(n^2)（虽然折半插入排序法与直接排序相比，改善了算法中比较次数的数量级，达到了O(nlogn)，但是没有改变交换元素的时间耗费，所以折半插入排序的时间复杂度仍然是O(n^2)。这种方法不经常使用，相同的适用场景下使用直接排序算法也可以解决问题。
- 空间稳定性：O(1)
- 稳定性：稳定

```c++
void sort(vector<int> &v, const int &n) {
    for (int i = 1; i < n - 1; ++i) {
        int temp = v[i];
        int left= 0, right = i - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (temp < v[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;//找到最后一个小于等于temp的位置，
                                // left-1处的元素符合，所以需要在left位置插入
            }
        }
        for (int j = i - 1; j >= left; --j) {
            v[j + 1] = v[j];
        }
        v[left] = temp;
    }
}
```

### 希尔排序

- 也是对直接排序的一种优化

- 思想：将元素分成了若干个较小的子序列，对子序列进行插入排序，使整个待排序序列排好序。

- 如何去分子序列？如果分成两组或者多组，虽然子序列是有序的，但是整体还是无序的。所以需要在分子序列时应该“跳着选”，而不是“连着选”。跳着选后子序列中排好序，会发现序列中较小的元素更靠前，大的元素更靠后，这样就比之前更加有序了。

- 示意图

  ![image-20230921211811651](./assets/image-20230921211811651.png)

- 时间复杂度：O(n^1.5) （gap的取值不同，时间复杂度也不同。gap=gap/3+1的时间复杂度为O(n^1.25)

  ~1.6*O(n^1.25)

- 空间复杂度：O(1)

- 稳定性：不稳定

```c++
void sort(vector<int> &v, const int &n) {
    int gap = n / 2;
    while (gap >= 1) {
        for (int i = gap; i < n; ++i) {
            int temp = v[i];
            for (int j = i - gap; j >= 0; j -= gap) {
                if (v[j] > temp) {
                    v[j + gap] = v[j];
                    v[j] = temp;
                } else {
                    break;
                }
            }
        }
        gap /= 2;
    }
    print(v);
}
```

## 选择类排序

### 简单选择排序

- 每一趟选出较大或者较小的值，将它与排好序后位于位置的值进行交换。

- 每一趟在n+i-1个元素中选取关键字最大或者最小的元素作为有序序列中的第i个元素。

- 过程描述：

  1. 第一趟从第一个元素开始，通过n-1个关键字的比较，从n个元素中获取到最小的元素（第一小），并与第一个元素进行交换（此时第一个元素是整体最小的）；

  2. 第二趟从第二个元素开始，通过n-2个关键字的比较，从n-1个元素获取到最小的元素（第二小），

     并与第二个元素进行交换（此时第二个元素是整体最小的）；

  3. ......

- 时间复杂度：O(n^2)

- 空间复杂度：O(1)

- 稳定性：不稳定

```c++
void sort(vector<int> &v, const int &n) {
    for (int i = 0; i < n - 1; ++i) {
        //第n个不需要比较
        int min = i;
        for (int j = i + 1; j < n; ++j) {
            if (v[min] > v[j]) {
                min = j;
            }
        }
        int temp = v[i];
        v[i] = v[min];
        v[min] = temp;
    }
}
```

### 树形选择排序

- 也称作锦标赛排序，是简单选择排序的改进算法。
- 在简单选择排序中，首先从n个元素中选择关键字最小的元素，需要n-1次比较，以此类推，每次都没有利用到上次的比较结果。所以比较操作的时间复杂度为O(n^2)。树形选择排序将比较过程中的比较结果保存了下来。
- 思想：先把待排序的n个元素两两进行比较，取出较小的，然后在n/2个较小者中采取同样的方法进行比较，取出较小者，如此反复，直到选出最小的元素为止。
- 这个思想可以用一颗满二叉树来表示，不满时用无穷大来补充，选出的最小的元素就是这棵树的根节点；将根节点输出后，叶子节点为最小值的变为无穷大，然后从该叶子节点和其兄弟节点进行比较，修改该叶子节点到根路径上各节点的值，则根节点的值为次小的值；
- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)
- 稳定性：稳定

### 堆排序

- 是树形选择排序的改进算法，弥补了树形选择排序占用空间太多的缺点。堆排序只需要一个记录大小的辅助空间

- 思想：将待排序的元素放在堆中，每个节点代表了一个元素。建立初堆后将根节点与堆的最后一个节点进行交换，之后重建堆的对象为n-1个，再把次大的元素与倒数第二个节点进行交换，之后重建堆的对象为n-2个，以此类推，直到重建堆的对象为0。此时将堆输出就是排好序的序列。

- 堆排序中主要涉及到两个问题，使用向下调整法去解决：

  - 按照堆的定义建立初堆；
  - 去掉最大元素后重建堆。

- 向下调整法：当完全二叉树不是大堆但是左右子树都是大堆时，需要调整满二叉树的根节点使其成为大堆。大堆每一个节点的值都大于等于它左右节点的值。此时根节点并不符合定义，所以我们需要将根节点换为所有节点中的最大值。

  - 如何找最大值？

    让根节点的左右孩子进行比较选出最大值，他们之间的较大值就是整个树的最大值（因为左右子树都是大堆）。

  将较大值所在的节点与根节点进行交换，此时根节点已经符合但是并不能确定原根节点现在位于的子树是否为最大堆，仍然需要进行判断，如果不是最大堆需要接着进行调整，直到符合堆的定义。

- 建立初堆：一开始接受的数据是无序的，需要从最后的子树开始向下调整。

  - 为什么一定要最后的子树：向下调整法使用的前提是堆根节点左右子树都是大堆，而一开始并不能确定这一点；
  - 如何确定最后的子树：最小子树的根节点没有左右子树，而它前面的节点都有左右子树。可以对树的节点进行编号，如果有n个节点从1开始编号，那么最后子树的根节点为n/2；0开始为(n-2)/2；

- 重建堆：当根节点移出后，它原来的位置就有了新的节点。新节点作为根节点可能不满足大堆的条件，需要堆根节点进行向下调整。

- 时间复杂度：O(nlogn)

- 空间复杂度：O(1)

- 稳定性：不稳定

  ```c++
  void adjustDown(vector<int> &v, int n, int root){
      int parent = root;
      int child = parent * 2 + 1;//从0开始编号
  //    升序建立大堆，降序建立小堆
      while (child < n) {
          if (child + 1 < n && v[child + 1] > v[child]) {
              //找到两个child中较大的那个
              child += 1;
          }
          if (v[child] > v[parent]) {
              //交换
              int temp = v[parent];
              v[parent] = v[child];
              v[child] = temp;
              //
              parent = child;
              child = parent * 2 + 1;
          } else {
              break;
          }
      }
  }
  void sort(vector<int> &v, const int &n) {
      if (v.empty()) {
          return;
      }
  //    开始建立初堆
      for (int i = (n - 2) / 2; i >= 0; --i) {
  //        找到最后一棵子树
          adjustDown(v, n, i);
      }
  //    从顶向下建立堆
      for (int i = 0; i < n - 1; ++i) {
          int temp = v[n - i - 1];
          v[n - i - 1] = v[0];
          v[0] = temp;
          adjustDown(v, n - i - 1, 0);
      }
  }
  ```

## 归并排序

- 思想：将两个或者两个以上的有序序列合并为一个
- 2-路归并：假设初始有n个元素，首先将这n个元素看成n个子序列，两两归并为有序的序列，此时序列的长度为2，然后再两两归并有序的序列，此时序列的长度为4……直到长度为n。<img src="./assets/image-20230922105610695.png" alt="image-20230922105610695" style="zoom:33%;" />

- 时间复杂度：O(nlogn）
- 空间复杂度：O(n）
- 稳定性：稳定


## 分治类排序

### 快速排序

- 基本思想：选择一个基准数，通过一趟排序将要排序的数据分割成两部分：一部分的所有数据都比另外一部分数据要小，然后再按照这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
- 流程
  1. 从数列中挑出一个基准值；
  2. 将所有比基准值小的摆放在基准前面，所有比基准值大的摆放在基准的后面（相同的数可以放到任意一边）；在这个分区退出后，该基准就处于数列的中间位置；
  3. 递归地把**基准值前面的子序列**和**基准值后面的子序列**进行排序。
- 时间复杂度：最坏是O(n^2)，平均是O(nlogn)
- 空间复杂度：最坏是O(n)，退化为冒泡排序；最好是O(logn)

- 稳定性：不稳定

<img src="./assets/image-20230922152938585.png" alt="image-20230922152938585" style="zoom: 33%;" />
	

```c++
void quick_sort(vector<int> &v, int left, int right) {
    if (left < right) {
        int i = left;
        int j = right;
        int temp = v[i];
        while (i < j) {
//            从右往左，找到比temp小的
            while (i < j && v[j] > temp) {
                j--;
            }
            if (i < j) {
                v[i++] = v[j];
            }
//            从左道右，找到比temp大的
            while (i < j && v[j] < temp) {
                i++;
            }
            if (i < j) {
                v[j--] = v[i];
            }
        }
        v[i] = temp;
        quick_sort(v, left, i - 1);
        quick_sort(v, i + 1, right);
    }
}
```

### 桶排序

- 思想：每个桶存储一定范围的元素，通过函数的某种映射关系，将待排序数组中的元素映射到各个对应的桶中，对每个桶中的元素进行排序（可能使用其他的排序算法或者以递归的方式继续使用桶排序），最后将非空桶中的元素逐个放入到原序列中。
- 需要尽量保证元素分散均匀，最后将非空桶中的元素逐个放入到原序列中。

## 分配类排序

### 多关键字排序

- 思想：先按照第一个关键字进行排序，将记录序列分成若干个子序列，每个子序列有相同的K1值；然后分别对每个子序列；然后分别对每个子序列按照第二个关键字K2进行排序，每个子序列又被分成若干个更小的子序列，如此反复，直到按照最后一个关键字Kd进行排序。最后将所有的子序列依次联接成一个有序的记录序列，该方法称为“高位优先”排序法。

### 链式基数排序

- 思想：基数排序属于上述“低位优先”排序法，通过反复进行分配和收集操作完成排序。排序时先按照最低位的值对元素进行初步排序，在此基础上再按照次低位的值进一步排序
- 稳定性：稳定

### 计数排序

- 对于给定的输入序列中的每一个元素，统计该序列中元素出现的次数，将元素出现次数存放起来，再从序列的最小值元素开始输出。